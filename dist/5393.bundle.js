"use strict";(self.webpackChunkui_geeks_in_web=self.webpackChunkui_geeks_in_web||[]).push([[5393],{15393:(e,t,n)=>{n.r(t),n.d(t,{default:()=>m});var l=n(67294),a=n(74214),r=n(91573),s=n(87398),c=n(68947),u=n(12050),o=n(9167);const m=function(){return l.createElement(l.Fragment,null,l.createElement(s.Z,{as:"h3"},"Adding State To Class Component"),l.createElement(c.Z,null,"The ",l.createElement(o.BI,null,'"this.state"')," variable holds the ",l.createElement(o.I,null,"state values"),". Let's try to understand the state with an example. Below ",l.createElement(o.B,null,"Counter"),l.createElement(u.Z,null)," component is a class component which uses the ",l.createElement(u.Z,null),l.createElement(o.I,null,"state variable")," to ",l.createElement(o.B,null,'"preserve"')," values between multiple renders. The ",l.createElement(o.BI,null,"this.state")," should always be an ",l.createElement(o.I,null,"object"),"."),l.createElement(a.Z,{language:r.r.JSX},"class Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { counter : 0 };\n  }\n\t\n  incrementCounter = () => {\n    this.setState((state) => ({ counter: state.counter + 1 });\n  }\n\n  render() {\n    return <div>\n      <span>Counter Value: {counter}</span>\n      <button onClick={this.incrementCounter}>Increment</button>\n    </div>\n  }\n}"),l.createElement(c.Z,null,l.createElement(o.B,null,"onClick={this.incrementCounter}"),l.createElement(o.cJ,null),"This adds the ",l.createElement(o.BI,null,'"click"')," event to the button here. The method",l.createElement(u.Z,null)," ",l.createElement(o.I,null,'"this.incrementCounter()"')," will be called once the user clicks the button."),l.createElement(c.Z,null,l.createElement(o.B,null,"super()"),": It is required to pass ",l.createElement(o.BI,null,'"props"')," to the ",l.createElement(u.Z,null),l.createElement(o.I,null,"base class")," constructor (i.e, constructor of React.Component). The",l.createElement(o.BI,null,"super()")," call initializes the ",l.createElement(o.BI,null,'"this"')," of our component."),l.createElement(c.Z,null,l.createElement(o.B,null,"this.state = { }"),l.createElement(o.cJ,null),"Above statement initializes the ",l.createElement(o.I,null,"state")," of the component. ",l.createElement(u.Z,null),l.createElement(o.B,null,"Constructor")," is the only place where we can ",l.createElement(o.BI,null,"initialize"),l.createElement(u.Z,null)," the state, all other places should only update the ",l.createElement(u.Z,null),l.createElement(o.I,null,"state")," ",l.createElement(u.Z,null)," values."),l.createElement(c.Z,null,l.createElement(o.B,null,"this.setState()"),l.createElement(o.cJ,null),"Any ",l.createElement(o.B,null,"update")," to the state value should be made by ",l.createElement(u.Z,null),l.createElement(o.BI,null,"this.setState()")," method. This method updates the value of state and ",l.createElement(o.BI,null,"triggers")," a ",l.createElement(o.BI,null,"re-render")," for the component."),l.createElement(c.Z,null,"The state updates may be ",l.createElement(o.B,null,"batched")," by React for ",l.createElement(u.Z,null),l.createElement(o.B,null,"performance benefits"),", which means it is not guaranteed the next state update will get the updated state values. But often there are use-cases where we need updated value before calling ",l.createElement(o.I,null,"setState()"),". To support this, ",l.createElement(o.BI,null,"this.setState()")," has ",l.createElement(o.B,null,"multiple")," syntaxes."),l.createElement(c.Z,null,"Let's learn about multiple syntaxes of ",l.createElement(o.I,null,"this.setState()")," method."),l.createElement(c.Z,null,l.createElement(o.IU,null,"Syntax 1:"),l.createElement(a.Z,null,"this.setState({ counter : this.state.counter + 1  });"),"This is a simpler syntax for updating the state value. But ",l.createElement(u.Z,null),l.createElement(o.BI,null,"do not guarantee")," the updated state value."),l.createElement(c.Z,null,l.createElement(o.IU,null,"Syntax 2:"),l.createElement(a.Z,null,"this.setState((state, props) => { \n  counter :  state.counter + props.counter + 1\n});"),"This uses a ",l.createElement(o.BI,null,"function syntax")," and provides the last updated value of ",l.createElement(o.BI,null,"state")," and ",l.createElement(o.BI,null,"props")," as input to the ",l.createElement(o.I,null,"setState()"),l.createElement(u.Z,null)," call."),l.createElement(c.Z,null,l.createElement(o.IU,null,"Syntax 3:"),l.createElement(c.Z,null,"There could be use-case, where we need to call other methods/statements after the state has been updated. For such use-cases, ",l.createElement(o.I,null,"setState()")," has an ",l.createElement(o.B,null,"optional second argument"),", which is a ",l.createElement(o.B,null,'"callback"'),' method. This "callback" is called once the state update is completed.'),l.createElement(a.Z,{language:r.r.JSX},"this.setState((state, props) => { \n  counter :  state.counter + props.counter + 1\n  }, () => {\n    // callback method\n    // This block will be executed, after the state update\n});"),l.createElement(c.Z,null,"When we call ",l.createElement(o.I,null,"setState()"),", React ",l.createElement(o.B,null,"merges")," the object we provide into the current state. The merging is ",l.createElement(o.B,null,"shallow"),", which means it will only update the given value, leaving other state values intact."),l.createElement(o.IU,null,"Example:"),l.createElement(c.Z,null,"Let's say our component has ",l.createElement(o.B,null,"2 state variables"),", and when we update one variable, it will not affect the other variable and vice-versa."),l.createElement(a.Z,{language:r.r.JSX},'this.state = {\n  counter : 0,\n  name : ""\n}\nthis.setState({ counter : this.state.counter + 1 });'),l.createElement(c.Z,null,"Above statement will increment the value of ",l.createElement(o.B,null,'"counter"')," but leave the value of ",l.createElement(o.B,null,'"name"')," intact."),l.createElement(c.Z,null,"Similarly, the below statement will only update the ",l.createElement(o.B,null,'"name"'),".",l.createElement(a.Z,{language:r.r.JSX},'this.setState({ name : "React do shallow merging." })'))))}},74214:(e,t,n)=>{n.d(t,{Z:()=>S});var l=n(4942),a=n(94184),r=n.n(a),s=n(67294),c=n(17606),u=n(83819),o=n(28949),m=n(93379),i=n.n(m),h=n(7795),E=n.n(h),d=n(90569),p=n.n(d),b=n(3565),v=n.n(b),g=n(19216),Z=n.n(g),B=n(44589),w=n.n(B),I=n(62428),f={};f.styleTagTransform=w(),f.setAttributes=v(),f.insert=p().bind(null,"head"),f.domAPI=E(),f.insertStyleElement=Z(),i()(I.Z,f),I.Z&&I.Z.locals&&I.Z.locals;var y=function(e){var t,n=e.children,a=e.language,m=void 0===a?"typescript":a,i=e.theme,h=e.showLineNumbers,E=void 0!==h&&h,d=e.codeBlock,p=void 0!==d&&d,b=e.highlight,v=e.copyBtn,g=void 0===v||v,Z=(0,s.useContext)(o.I),B=r()((t={},(0,l.Z)(t,"".concat(u.HL,"-code"),!0),(0,l.Z)(t,"".concat(u.HL,"-code-no-copy-btn"),!g),t));return s.createElement("div",{className:B,style:{textAlign:"left"}},s.createElement(c.Z1,{text:n,language:m,showLineNumbers:E,theme:function(){switch(i){case"dracula":return c.cL;case"anOldHope":return c.dw;case"github":return c.bW;default:return Z.theme===u.bF.DARK_THEME?c.g9:c.dw}}(),wrapLines:!0,codeBlock:p,highlight:b}))};const S=(0,s.memo)(y)},91573:(e,t,n)=>{n.d(t,{r:()=>l});var l={JavaScript:"javascript",TypeScript:"typescript",HTML:"html",CSS:"css",JSX:"jsx"}},62428:(e,t,n)=>{n.d(t,{Z:()=>c});var l=n(8081),a=n.n(l),r=n(23645),s=n.n(r)()(a());s.push([e.id,".ui-geeks-code{margin-top:1.5rem;margin-bottom:1.5rem}.ui-geeks-code-no-copy-btn button{display:none}\n",""]);const c=s}}]);