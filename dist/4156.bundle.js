"use strict";(self.webpackChunkui_geeks_in_web=self.webpackChunkui_geeks_in_web||[]).push([[4156],{84156:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});var l=n(67294),r=n(74214),a=n(87398),o=n(68947),c=n(12050),u=n(9167);const i=function(){return l.createElement(l.Fragment,null,l.createElement(a.Z,{as:"h2"},"Iterables"),l.createElement(o.Z,null,"An ",l.createElement(u.I,null,"object")," is ",l.createElement(u.BI,null,"iterable"),", if it defines its iteration behavior. In order to be ",l.createElement(u.I,null,"iterable"),", an ",l.createElement(u.I,null,"object")," must implement the ",l.createElement(u.BI,null,"@@iterator")," method. This means that the",l.createElement(c.Z,null)," ",l.createElement(u.I,null,"object")," must have a property with a",l.createElement(u.BI,null,"Symbol.iterator")," ",l.createElement(u.I,null,"key"),". It may be possible to iterate over an iterable more than once or only once."),l.createElement(o.Z,null,l.createElement(u.BI,null,"Iterables")," which can iterate ",l.createElement(u.B,null,"only once")," (such as ",l.createElement(c.Z,null),l.createElement(u.I,null,"Generators"),") return ",l.createElement(u.BI,null,"this")," from their ",l.createElement(u.BI,null,"@@iterator"),l.createElement(c.Z,null)," method, whereas ",l.createElement(u.BI,null,"iterables")," which can be iterated",l.createElement(u.B,null,"many times")," must return a ",l.createElement(u.BI,null,"new iterator")," on each invocation of ",l.createElement(u.BI,null,"@@iterator"),"."),l.createElement(o.Z,null,l.createElement(u.IU,null,"Example 1:"),l.createElement(u.cJ,null),"Implementing an ",l.createElement(u.I,null,"iterable")," which can iterate ",l.createElement(u.B,null,"only once"),"."),l.createElement(o.Z,null,l.createElement(o.Z,null,"In below code, statement ",l.createElement(u.BI,null,"it[Symbol.iterator]() === it"),l.createElement(c.Z,null)," returned ",l.createElement(u.B,null,"true"),", i.e., ",l.createElement(u.I,null,"@@iterator")," method is returning itself, which shows this iterate only once."),l.createElement(r.Z,null,"function* makeIterator() {\n  yield 1;\n  yield 2;\n}\nconst it = makeIterator();\n\nfor(const itm of it) { console.log(itm); }\n// Output:\n// 1\n// 2\nit[Symbol.iterator]() === it;  // true\n"),l.createElement(o.Z,null,"Also, If we try to replicate the",l.createElement(u.BI,null,"for…of loop"),", it will not print in the console again, proving that it only iterates once."),l.createElement(r.Z,null,"const it = makeIterator();\nfor(const itm of it) { console.log(itm); }\n// Output:\n// 1\n// 2\n\nfor(const itm of it) { console.log(itm); }\n// Not output on console\n")),l.createElement(o.Z,null,l.createElement(u.IU,null,"Example 2:"),l.createElement(u.cJ,null),"Implementing an ",l.createElement(u.I,null,"iterable")," which can iterate ",l.createElement(u.B,null,"many times"),".",l.createElement(r.Z,null,"function* makeIterator() {\n  yield 1;\n  yield 2;\n}\n\nconst it = makeIterator();\nit[Symbol.iterator] = function*() {\n  yield 1;\n  yield 2;\n}\n\nfor(const itm of it) { \tconsole.log(itm); }\n// Output:\n// 1\n// 2\n\nfor(const itm of it) { \tconsole.log(itm); }\n// Output:\n// 1\n// 2\n"),l.createElement(o.Z,null,"In above code, both ",l.createElement(u.BI,null,"for…of")," loop printed numbers on the console, proving that it can iterate many times.")),l.createElement(o.Z,null,l.createElement(u.B,null,"next()"),": The ",l.createElement(u.I,null,"next()")," method also accepts a parameter value, which can be used to modify the internal state of the generator. A value passed to ",l.createElement(u.I,null,"next()")," will be received by ",l.createElement(u.BI,null,"yield"),". A value passed to the ",l.createElement(u.B,null,"first invocation")," of ",l.createElement(u.I,null,"next()")," is always ignored."),l.createElement(o.Z,null,l.createElement(u.IU,null,"Exmaple:"),l.createElement(r.Z,null,"function* fibonacci() {\n  let current = 0;\n  let next = 1;\n  while(true) {\n    const reset = yield current;\n    // Value passed to next() will be read here by yield current.\n\n    [current, next] = [next, next + current];\n    if(reset) {\n      current = 0;\n      next = 1;\n    }\n  }\t\n}\n\nconst sequence = fibonacci();\nsequence.next()\nconsole.log(sequence.next().value);  // 1\nsequence.next()\nconsole.log(sequence.next().value);  // 2\nsequence.next()\nconsole.log(sequence.next().value);  // 5\nsequence.next(true);  // Resetting here\nconsole.log(sequence.next().value);  // 1\n")),l.createElement(o.Z,null,l.createElement(u.B,null,"return()")," : Generators have a ",l.createElement(u.BI,null,"return(value)"),l.createElement(c.Z,null)," method that returns the given value and finishes the generator itself, and allows the generator to perform any cleanup tasks when combined with ",l.createElement(u.BI,null,"try…finally block"),". If the ",l.createElement(u.BI,null,"yield"),l.createElement(c.Z,null)," expression is wrapped in a ",l.createElement(u.I,null,"try…finally")," block, the control flow doesn't exit the ",l.createElement(u.I,null,"function body"),", but proceeds to the",l.createElement(u.I,null,"finally")," block instead."),l.createElement(o.Z,null,l.createElement(u.IU,null,"Example:"),l.createElement(u.cJ,null),l.createElement(r.Z,null,'function* generatorFunc() {\n  yield 1;\n  yield 2;\n}\n\nconst g = generatorFunc();\ng.next(); // { value: 1, dne: false }\n\ng.return("return value"); // { value: "return value", done: true }\n// Finishes the generator and returns the value passed to return() method.\n'),l.createElement(o.Z,null,"Below code finishes the generator and returns the value passed to return() method.",l.createElement(r.Z,null,'g.return("return value");\n// { value: "return value", done: true }')),l.createElement(o.Z,null,"Because generator was terminated by ",l.createElement(u.BI,null,'g.return("return value")'),l.createElement(c.Z,null)," statement. Now, if we call ",l.createElement(u.I,null,"next()")," methods, we'll get"," ",l.createElement(u.I,null,"value")," as ",l.createElement(u.BI,null,"undefined"),"."),l.createElement(r.Z,null,"g.next();\t\n// { value: undefined, done: true }")))}},74214:(e,t,n)=>{n.d(t,{Z:()=>x});var l=n(4942),r=n(94184),a=n.n(r),o=n(67294),c=n(17606),u=n(83819),i=n(28949),m=n(93379),s=n.n(m),E=n(7795),h=n.n(E),d=n(90569),I=n.n(d),f=n(3565),b=n.n(f),g=n(19216),p=n.n(g),y=n(44589),v=n.n(y),Z=n(62428),w={};w.styleTagTransform=v(),w.setAttributes=b(),w.insert=I().bind(null,"head"),w.domAPI=h(),w.insertStyleElement=p(),s()(Z.Z,w),Z.Z&&Z.Z.locals&&Z.Z.locals;var B=function(e){var t,n=e.children,r=e.language,m=void 0===r?"typescript":r,s=e.theme,E=e.showLineNumbers,h=void 0!==E&&E,d=e.codeBlock,I=void 0!==d&&d,f=e.highlight,b=e.copyBtn,g=void 0===b||b,p=(0,o.useContext)(i.I),y=a()((t={},(0,l.Z)(t,"".concat(u.HL,"-code"),!0),(0,l.Z)(t,"".concat(u.HL,"-code-no-copy-btn"),!g),t));return o.createElement("div",{className:y,style:{textAlign:"left"}},o.createElement(c.Z1,{text:n,language:m,showLineNumbers:h,theme:function(){switch(s){case"dracula":return c.cL;case"anOldHope":return c.dw;case"github":return c.bW;default:return p.theme===u.bF.DARK_THEME?c.g9:c.dw}}(),wrapLines:!0,codeBlock:I,highlight:f}))};const x=(0,o.memo)(B)},62428:(e,t,n)=>{n.d(t,{Z:()=>c});var l=n(8081),r=n.n(l),a=n(23645),o=n.n(a)()(r());o.push([e.id,".ui-geeks-code{margin-top:1.5rem;margin-bottom:1.5rem}.ui-geeks-code-no-copy-btn button{display:none}\n",""]);const c=o}}]);