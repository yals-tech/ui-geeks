"use strict";(self.webpackChunkui_geeks_in_web=self.webpackChunkui_geeks_in_web||[]).push([[4788],{4788:(e,t,n)=>{n.r(t),n.d(t,{default:()=>s});var l=n(67294),r=n(87398),a=n(68947),o=n(9167),c=[{label:l.createElement(l.Fragment,null,"When ",l.createElement(o.B,null,"Provider value prop")," changes, it will ",l.createElement(o.B,null,"re-render")," all the child components below the current component, irrespective of the implementation of ",l.createElement(o.I,null,"shouldComponentUpdate()")," lifecycle method. This may cause performance issues.")},{label:l.createElement(l.Fragment,null,l.createElement(o.B,null,"Provider value prop")," update has to be made with caution, because it will only ",l.createElement(o.B,null,"re-render")," the child components ",l.createElement(o.B,null,"below")," the current component and not the components ",l.createElement(o.B,null,"above")," the current component in the component tree.")}];const s=function(){return l.createElement(l.Fragment,null,l.createElement(r.Z,{as:"h2"},"Issues using Context"),l.createElement(a.Z,null,"Although Context is a good fit for sharing data between parent and child components in a deeply nested component tree. Still, there are a couple of issues with the re-rendering mechanism of Context."),l.createElement(a.Z,null,"Let's learn few of the issues:"),l.createElement(o.GS,{unOrdered:!0,expanded:!0,items:c}))}}}]);